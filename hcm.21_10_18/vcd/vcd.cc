//
// A Library for VCD output for an HCM top cell and sons
// 

#include <errno.h>
#include <signal.h>
#include <sstream>
#include <algorithm>
#include <iostream>
#include "vcd.h"

using namespace std;

///////////////////////////////////////////////////////////////////////////
vcdNodeCtx::vcdNodeCtx(list<std::string> &p, std::string n)
{
  nodeName = n;
  parentInstNames = p;
}

string
vcdNodeCtx::getName() const
{
  string res;
  bool first = true;
  list<string>::const_iterator pI;
  for (pI = parentInstNames.begin(); pI != parentInstNames.end(); pI++) {
    if (!first) 
      res += string("/");
    else
      first = false;
    res += (*pI);
  }
  if (!first) 
    res += string("/");
  res += nodeName;
  return res;
}

///////////////////////////////////////////////////////////////////////////

// get the string of the VCD code based on an integer 
string 
vcdFormatter::getVCDId(int id) 
{
  ostringstream s;
  string res;
  static int base = '~' - '!';
  while (id) {
    char digit = id % base + '!';
    s << (char)digit;
    id = id / base;
  }
  res = s.str();
  reverse(res.begin(), res.end());
  return res;
}

// get the code of the given node context
string 
vcdFormatter::getNodeCtxCode(const vcdNodeCtx *nodeCtx)
{
  string res;
  map< const vcdNodeCtx *, std::string, cmpNodeCtx >::const_iterator cI;
  cI = codeByNodeCtx.find(nodeCtx);
  if (cI == codeByNodeCtx.end()) 
	 return(res);

  return((*cI).second);
}

#ifdef DEBUG
static string join(list<string> l) {
  string r;
  list<string>::const_iterator I;
  for (I = l.begin(); I != l.end() ; I++) {
	 if (r.size()) {
		r += "/";
	 }
	 r += *I;
  }
  return r;
}
#endif

// should be called with empty parents for top
int 
vcdFormatter::genVCDScope(set< vcdNodeCtx, cmpNodeCtx > &vcdNodes)
{
  string prefix("");
  vcd << "$scope module DUT $end" << endl;
  //  prefix = prefix + " ";
  list<string>::const_iterator pI, qI;

  // we start with empty parents list
  list<string> prevParentInstNames;

  // since the set of node contexts is sorted already we can simply use it
  set< vcdNodeCtx, cmpNodeCtx >::const_iterator ncI;
  for (ncI = vcdNodes.begin(); ncI != vcdNodes.end(); ncI++) {
	 const vcdNodeCtx *nodeCtx = &(*ncI);
    string code = getVCDId(codeByNodeCtx.size()+1);
	 codeByNodeCtx[nodeCtx] = code;

	 // prev ctx parents may be a/b/c... and new one is x/y/z...
	 // find the length of the common parents list
	 size_t commDepth = 0;
	 if (prevParentInstNames != nodeCtx->parentInstNames) {
		pI = nodeCtx->parentInstNames.begin();
		qI = prevParentInstNames.begin();
		while ((pI != nodeCtx->parentInstNames.end()) &&
				 (qI != prevParentInstNames.end()) && 
				 (*pI == *qI)) {
		  commDepth++;
		  pI++;
		  qI++;
		}
		
		// close the hierarchies below prev context
		// if (qI != prevParentInstNames.end())
		//  vcd << "$comment E: " << join(prevParentInstNames) << " $end " << endl;

		while (qI != prevParentInstNames.end()) {
		  //		prefix = prefix.substr(0, prefix.size() - 1);
		  vcd << prefix << "$upscope $end" << endl;
		  qI++;
		}
		while (pI != nodeCtx->parentInstNames.end()) {
		  vcd << prefix << "$scope module " << (*pI) << " $end" << endl;
		  //		prefix = prefix + " ";
		  pI++;
		}
		// vcd << "$comment S: " << join(nodeCtx->parentInstNames) << " $end" << endl;
	 }
	 // print the node
    vcd << "$var wire 1 " << code << " " << nodeCtx->nodeName << " $end" << endl;
	 prevParentInstNames = nodeCtx->parentInstNames;
  }
  qI = prevParentInstNames.begin();
  while (qI != prevParentInstNames.end()) {
	 // prefix = prefix.substr(0, prefix.size() - 1);
	 vcd << prefix << "$upscope $end" << endl;
	 qI++;
  }
  vcd << prefix << "$upscope $end" << endl;

  return(0);
}

int 
vcdFormatter::genVCDHeader(set< vcdNodeCtx, cmpNodeCtx > &vcdNodes)
{
  time_t rawtime;
  time (&rawtime);
  vcd << "$date" << endl;
  vcd << "     " << ctime(&rawtime) << endl;
  vcd << "$end" << endl;
  vcd << "$version" << endl;
  vcd << "     Generated by HCM VCD formatter for cell: " << topCellName << endl;
  vcd << "$end" << endl;
  vcd << "$timescale" << endl;
  vcd << "     1s" << endl;
  vcd << "$end" << endl;

  if (genVCDScope(vcdNodes))
    return(1);

  vcd << "$enddefinitions $end" << endl;
  vcd << "#0" << endl; 
  vcd << "$dumpvars" << endl;
  return(0);  
}

// constractor
vcdFormatter::vcdFormatter(std::string fileName, std::string cellName, 
									std::set< vcdNodeCtx, cmpNodeCtx > &vcdNodes)
{
  topCellName = cellName;
  vcd.open(fileName.c_str());
  if (!vcd.good()) {
    is_good = false;
    return;
  }

  if (genVCDHeader(vcdNodes)) {
    is_good = false;
    return;
  }
  is_good = true;
}

// destructor = close the file
vcdFormatter::~vcdFormatter() 
{
  codeByNodeCtx.clear();
}

// Change the time
int 
vcdFormatter::changeTime(unsigned long int newTime)
{
  vcd << "#" << newTime << endl;
  return(0);
}

// Declare a change of value
// return 0 if successful (-1 if node does not exist)
int 
vcdFormatter::changeValue(string code, bool value)
{
  vcd << (value ? "1" : "0") << code << endl;  
  return(0);
}

