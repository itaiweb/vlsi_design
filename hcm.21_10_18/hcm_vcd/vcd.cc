//
// A Library for VCD output for an HCM top cell and sons
// 

#include <errno.h>
#include <signal.h>
#include <sstream>
#include <algorithm>
#include "hcmvcd.h"

using namespace std;

///////////////////////////////////////////////////////////////////////////
hcmNodeCtx::hcmNodeCtx(list<const hcmInstance *> &p, const hcmNode *n)
{
  node = n;
  parentInsts = p;
}

string
hcmNodeCtx::getName() const
{
  string res;
  bool first = true;
  list<const hcmInstance *>::const_iterator pI;
  for (pI = parentInsts.begin(); pI != parentInsts.end(); pI++) {
    if (!first) 
      res += string("/");
    else
      first = false;
    res += (*pI)->getName();
  }
  if (!first) 
    res += string("/");
  res += node->getName();
  return res;
}

///////////////////////////////////////////////////////////////////////////

// get the string of the VCD code based on an integer 
string 
vcdFormatter::getVCDId(int id) 
{
  ostringstream s;
  string res;
  static int base = '~' - '!';
  while (id) {
    char digit = id % base + '!';
    s << (char)digit;
    id = id / base;
  }
  res = s.str();
  reverse(res.begin(), res.end());
  return res;
}

// should be called with empty parents for top
int 
vcdFormatter::dfsVCDScope(list<const hcmInstance *> &parentInsts)
{
  const hcmCell *cell;
  const hcmInstance *inst = NULL;
  if (!parentInsts.empty()) {
    inst = parentInsts.back();
  }

  // top level is named DUT
  if (inst) {
    vcd << "$scope module " << inst->getName() << " $end" << endl;
    cell = inst->masterCell();
  } else {
    vcd << "$scope module DUT $end" << endl;
    cell = topCell;
  }

  // dump out all local nodes in this level that are not external
  map< string, hcmNode* >::const_iterator nI;
  const map< string, hcmNode* > &nodesMap = cell->getNodes();
  for (nI = nodesMap.begin(); nI != nodesMap.end(); nI++) {
    const hcmNode *node = (*nI).second;
    string name = node->getName();
    if (node->getPort() && !parentInsts.empty()) 
      continue;

    if (glbNodeNames.find(name) != glbNodeNames.end()) 
      continue;

    // allocate new code and remember it
    string code = getVCDId(codeByNodeCtx.size()+1);
    hcmNodeCtx nodeCtx(parentInsts, node);
    codeByNodeCtx[nodeCtx] = code;
    vcd << "$var wire 1 " << code << " " << name << " $end" << endl;
  }
  
  // recurse on all instances
  map< string, hcmInstance* >::const_iterator iI;
  for (iI = cell->getInstances().begin(); iI != cell->getInstances().end(); iI++) { 
    list<const hcmInstance *> iParents = parentInsts;
    iParents.push_back((*iI).second);
    dfsVCDScope(iParents);
  }

  vcd << "$upscope $end" << endl;
  return(0);
}

int 
vcdFormatter::genVCDHeader()
{
  time_t rawtime;
  time (&rawtime);
  vcd << "$date" << endl;
  vcd << "     " << ctime(&rawtime) << endl;
  vcd << "$end" << endl;
  vcd << "$version" << endl;
  vcd << "     Generated by HCM VCD formatter for cell: " << topCell->getName() << endl;
  vcd << "$end" << endl;
  vcd << "$timescale" << endl;
  vcd << "     1s" << endl;
  vcd << "$end" << endl;

  list<const hcmInstance *> noParents;
  if (dfsVCDScope(noParents)) 
    return(1);

  vcd << "$enddefinitions $end" << endl;
  vcd << "#0" << endl; 
  vcd << "$dumpvars" << endl;
  return(0);  
}

// constractor
vcdFormatter::vcdFormatter(string fileName, const hcmCell *cell, set<string> &g)
{
  topCell = cell;
  vcd.open(fileName.c_str());
  if (!vcd.good()) {
    is_good = false;
    return;
  }

  glbNodeNames = g;

  if (genVCDHeader()) {
    is_good = false;
    return;
  }
  is_good = true;

}

// destructor = close the file
vcdFormatter::~vcdFormatter() 
{
  codeByNodeCtx.clear();
}

// Change the time
int 
vcdFormatter::changeTime(unsigned long int newTime)
{
  vcd << "#" << newTime << endl;
  return(0);
}

// Declare a change of value
// return 0 if successful (-1 if node does not exist)
int 
vcdFormatter::changeValue(const hcmNodeCtx *nodeCtx, bool value)
{
  map< const hcmNodeCtx, string, cmpNodeCtx >::const_iterator cI = codeByNodeCtx.find(*nodeCtx);
  if (cI == codeByNodeCtx.end()) {
    cerr << "-E- Could not find VCD context for node: " << nodeCtx->getName() << endl;
    return(1);
  }
  string code = (*cI).second;
  vcd << (value ? "1" : "0") << code << endl;
  
  return(0);
}

